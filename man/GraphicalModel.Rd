% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/graphical_model.R
\name{GraphicalModel}
\alias{GraphicalModel}
\title{Stability selection graphical model}
\usage{
GraphicalModel(
  xdata,
  pk = NULL,
  Lambda = NULL,
  lambda_other_blocks = 0.1,
  pi_list = seq(0.6, 0.9, by = 0.01),
  K = 100,
  tau = 0.5,
  seed = 1,
  n_cat = 3,
  implementation = PenalisedGraphical,
  start = "warm",
  scale = TRUE,
  resampling = "subsampling",
  cpss = FALSE,
  PFER_method = "MB",
  PFER_thr = Inf,
  FDP_thr = Inf,
  Lambda_cardinal = 50,
  lambda_max = NULL,
  lambda_path_factor = 0.001,
  max_density = 0.5,
  n_cores = 1,
  output_data = FALSE,
  verbose = TRUE,
  ...
)
}
\arguments{
\item{xdata}{data matrix with observations as rows and variables as columns.
For multi-block stability selection, the variables in data have to be
ordered by group.}

\item{pk}{optional vector encoding the grouping structure. Only used for
multi-block stability selection where \code{pk} indicates the number of
variables in each group. If \code{pk=NULL}, single-block stability
selection is performed.}

\item{Lambda}{matrix of parameters controlling the level of sparsity in the
underlying feature selection algorithm specified in \code{implementation}.
If \code{implementation=PenalisedGraphical}, \code{Lambda} contains penalty
parameters. If \code{Lambda=NULL}, \code{\link{LambdaGridGraphical}} is
used to define a relevant grid. \code{Lambda} can be provided as a vector
or a matrix with \code{length(pk)} columns. If \code{implementation} is not
set to \code{PenalisedGraphical}, \code{Lambda} must be provided.}

\item{lambda_other_blocks}{optional vector of parameters controlling the
level of sparsity in neighbour blocks for the multi-block procedure. To use
jointly a specific set of parameters for each block,
\code{lambda_other_blocks} must be set to \code{NULL} (not recommended).
Only used for multi-block stability selection, i.e. if \code{length(pk)>1}.}

\item{pi_list}{vector of thresholds in selection proportions. If
\code{n_cat=3}, these values must be \code{>0.5} and \code{<1}. If
\code{n_cat=2}, these values must be \code{>0} and \code{<1}.}

\item{K}{number of resampling iterations.}

\item{tau}{subsample size. Only used with \code{resampling="subsampling"}.}

\item{seed}{value of the seed to ensure reproducibility of the results.}

\item{n_cat}{number of categories used to compute the stability score.
Possible values are 2 or 3.}

\item{implementation}{function to use for graphical modelling. If
\code{implementation=PenalisedGraphical}, the algorithm implemented in
\code{\link[glassoFast]{glassoFast}} is used for regularised estimation of
a conditional independence graph. Alternatively, a function taking
\code{xdata} and \code{Lambda} as arguments and returning a binary and
symmetric matrix for which diagonal elements are equal to zero can be used.}

\item{start}{character string indicating if the algorithm should be
initialised at the estimated (inverse) covariance with previous penalty
parameters (\code{start="warm"}) or not (\code{start="cold"}). Using
\code{start="warm"} can speed-up the computations, but could lead to
convergence issues (in particular with small \code{Lambda_cardinal}). Only
used for \code{implementation=PenalisedGraphical} (see argument
\code{"start"} in \code{\link[glassoFast]{glassoFast}}).}

\item{scale}{logical indicating if the correlation (\code{scale=TRUE}) or
covariance (\code{scale=FALSE}) matrix should be used as input of
\code{\link[glassoFast]{glassoFast}} if
\code{implementation=PenalisedGraphical}. Otherwise, this argument must be
used in the function provided in \code{implementation}.}

\item{resampling}{resampling approach. Possible values are:
\code{"subsampling"} for sampling without replacement of a proportion
\code{tau} of the observations, or \code{"bootstrap"} for sampling with
replacement generating a resampled dataset with as many observations as in
the full sample. Alternatively, this argument can be a function to use for
resampling. This function must use arguments named \code{data} and
\code{tau} and return IDs of observations to be included in the resampled
dataset (see example in \code{\link{Resample}}).}

\item{cpss}{logical indicating if complementary pair stability selection
should be done. For this, the algorithm is applied on two non-overlapping
subsets of half of the observations. A feature is considered as selected if
it is selected for both subsets. With this method, the data is split
\code{K/2} times (\code{K} models are fitted). If \code{PFER_method="SS"},
complementary pair stability selection is used (\code{cpss} is set to
\code{TRUE}). Argument \code{tau} is ignored if \code{cpss=TRUE}.}

\item{PFER_method}{method used to compute the upper-bound of the expected
number of False Positives (or Per Family Error Rate, PFER). With
\code{PFER_method="MB"}, the method proposed by Meinshausen and BÃ¼hlmann
(2010) is used. With \code{PFER_method="SS"}, the method proposed by Shah
and Samworth (2013) under the assumption of unimodality is used.}

\item{PFER_thr}{threshold in PFER for constrained calibration by error
control. With \code{PFER_thr=Inf} and \code{FDP_thr=Inf}, unconstrained
calibration is used.}

\item{FDP_thr}{threshold in the expected proportion of falsely selected
features (or False Discovery Proportion, FDP) for constrained calibration
by error control. With \code{PFER_thr=Inf} and \code{FDP_thr=Inf},
unconstrained calibration is used.}

\item{Lambda_cardinal}{number of values in the grid of parameters controlling
the level of sparsity in the underlying algorithm.}

\item{lambda_max}{optional maximum value for the grid in penalty parameters.
If \code{lambda_max=NULL}, the maximum value is set to the maximum
covariance in absolute value. Only used if
\code{implementation=PenalisedGraphical} and \code{Lambda=NULL}.}

\item{lambda_path_factor}{multiplicative factor used to define the minimum
value in the grid.}

\item{max_density}{threshold on the density. The grid is defined such that
the density of the estimated graph does not exceed max_density.}

\item{n_cores}{number of cores to use for parallel computing. Only available
on Unix systems.}

\item{output_data}{logical indicating if the input datasets \code{xdata} and
\code{ydata} should be included in the output.}

\item{verbose}{logical indicating if a loading bar and messages should be
printed.}

\item{...}{additional parameters passed to the functions provided in
\code{implementation} or \code{resampling}.}
}
\value{
A list with: \item{S}{a matrix of the best (block-specific) stability
  scores for different (sets of) parameters controlling the level of sparsity
  in the underlying algorithm. } \item{Lambda}{a matrix of (block-specific)
  parameters controlling the level of sparsity. } \item{Q}{a matrix of
  average numbers of (block-specific) edges selected by the underlying
  algorihm for different (sets of) parameters controlling the level of
  sparsity.} \item{Q_s}{a matrix of calibrated numbers of (block-specific)
  stable edges for different (sets of) parameters controlling the level of
  sparsity in the underlying algorithm. } \item{P}{a matrix of calibrated
  (block-specific) thresholds in selection proportions for different (sets
  of) parameters controlling the level of sparsity in the underlying
  algorithm. } \item{PFER}{a matrix of the (block-specific) upper-bounds in
  PFER of calibrated stability selection models with different (sets of)
  parameters controlling the level of sparsity in the underlying algorithm.}
  \item{FDP}{a matrix of the (block-specific) upper-bounds in FDP of
  calibrated stability selection models with different (sets of) parameters
  controlling the level of sparsity in the underlying algorithm.}
  \item{S_2d}{an array of (block-specific) stability scores obtained with
  different combinations of parameters. Columns correspond to different
  thresholds in selection proportions. In multi-block stability selection,
  indices along the third dimension correspond to different blocks.}
  \item{PFER_2d}{an array of computed upper-bounds of PFER obtained with
  different combinations of parameters. Columns correspond to different
  thresholds in selection proportions. Only available for single-block
  stability selection.} \item{FDP_2d}{an array of computed upper-bounds of
  FDP obtained with different combinations of parameters. Columns correspond
  to different thresholds in selection proportions. Only available for
  single-block stability selection.} \item{selprop}{an array of selection
  proportions. Rows and columns correspond to nodes in the graph. Indices
  along the third dimension correspond to different (sets of) parameters
  controlling the level of sparsity in the underlying algorithm.}
  \item{sign}{a matrix of signs of Pearson's correlations estimated from
  \code{xdata}.} \item{method}{a list with \code{type="graphical_model"},
  \code{implementation}, \code{start}, \code{resampling} and
  \code{PFER_method} values used for the run.} \item{params}{a list with
  values of other objects used for the run.} For all objects except
  \code{selprop}, \code{sign} and those stored in \code{methods} or
  \code{params}, rows correspond to parameter values stored in the output
  \code{Lambda}. In multi-block stability selection, columns of these same
  objects correspond to different blocks.
}
\description{
Runs stability selection graphical models with different combinations of
parameters controlling the sparsity of the underlying selection algorithm
(e.g. penalty parameter for regularised models) and thresholds in selection
proportions. These two parameters are jointly calibrated by maximising the
stability score of the model (possibly under a constraint on the expected
number of falsely stably selected features).
}
\details{
To ensure reproducibility of the results, the state of the random
  number generator is fixed to \code{seed}. For parallelisation of the code,
  stability selection results produced with different \code{seed}s and all
  other parameters equal can be combined (more details in
  \code{\link{Combine}}).
}
\examples{
\dontshow{
# Single-block stability selection
set.seed(1)
simul <- SimulateGraphical(n = 50, pk = 30, nu_within = 0.05)
stab <- GraphicalModel(xdata = simul$data, K = 5, verbose = FALSE)
CalibrationPlot(stab)
SelectionProportions(stab)
}
\dontrun{

## Single-block stability selection

# Data simulation
set.seed(1)
simul <- SimulateGraphical(n = 100, pk = 20, nu_within = 0.1)

# Stability selection
stab <- GraphicalModel(xdata = simul$data)
print(stab)

# Calibration heatmap
par(mar = rep(7, 4))
CalibrationPlot(stab)

# Visualisation of the results
summary(stab)
plot(stab)

# Extraction of adjacency matrix or igraph object
Adjacency(stab)
Graph(stab)


## Multi-block stability selection

# Data simulation
set.seed(1)
simul <- SimulateGraphical(pk = c(10, 10))

# Stability selection
stab <- GraphicalModel(xdata = simul$data, pk = c(10, 10), Lambda_cardinal = 10)
print(stab)

# Calibration heatmap
par(mar = rep(7, 4), mfrow = c(1, 3))
CalibrationPlot(stab)

# Visualisation of the results
summary(stab)
par(mfrow = c(1, 1))
plot(stab)

# Multi-parameter stability selection (not recommended)
Lambda <- matrix(c(0.8, 0.6, 0.3, 0.5, 0.4, 0.3, 0.7, 0.5, 0.1), ncol = 3)
stab <- GraphicalModel(
  xdata = simul$data, pk = c(10, 10),
  Lambda = Lambda, lambda_other_blocks = NULL
)
stab$Lambda


## Example with user-defined function: shrinkage estimation and selection

# Data simulation
set.seed(1)
simul <- SimulateGraphical(n = 100, pk = 20, nu_within = 0.1)

if (requireNamespace("corpcor", quietly = TRUE)) {
  # Writing user-defined algorithm in a portable function
  ShrinkageSelection <- function(xdata, Lambda, ...) {
    mypcor <- corpcor::pcor.shrink(xdata, verbose = FALSE)
    adjacency <- array(NA, dim = c(nrow(mypcor), ncol(mypcor), nrow(Lambda)))
    for (k in 1:nrow(Lambda)) {
      A <- ifelse(abs(mypcor) >= Lambda[k, 1], yes = 1, no = 0)
      diag(A) <- 0
      adjacency[, , k] <- A
    }
    return(adjacency)
  }

  # Running the algorithm without stability
  myglasso <- GraphicalAlgo(
    xdata = simul$data,
    Lambda = matrix(c(0.05, 0.1), ncol = 1), implementation = ShrinkageSelection
  )

  # Stability selection using shrinkage estimation and selection
  stab <- GraphicalModel(
    xdata = simul$data, Lambda = matrix(c(0.01, 0.05, 0.1), ncol = 1),
    implementation = ShrinkageSelection
  )
  stable_adjacency <- Adjacency(stab)
}


## Example for the detection of block structure

# Data simulation
set.seed(1)
pk <- sample(1:5, size = 5, replace = TRUE)
simul <- SimulateComponents(
  n = 100, pk = pk,
  v_within = c(0.7, 0.8), v_sign = -1
)

# Data visualisation
par(mar = c(5, 5, 5, 5))
Heatmap(
  mat = cor(simul$data),
  colours = c("navy", "white", "red"),
  legend_range = c(-1, 1)
)

# Stability-based clustering of variables
stab <- GraphicalModel(
  xdata = simul$data, Lambda = seq(2, ncol(simul$data)),
  implementation = HierarchicalClustering
)

# Calibration heatmap
CalibrationPlot(stab, xlab = "k")

# Extraction of stable clusters
Clusters(stab)

# Clustering performance (for simulations only)
ClusteringPerformance(
  theta = Clusters(stab),
  theta_star = simul$membership
)
}
}
\references{
\insertRef{ourstabilityselection}{focus}

  \insertRef{stabilityselectionMB}{focus}

  \insertRef{stabilityselectionSS}{focus}
}
\seealso{
\code{\link{Graph}}, \code{\link{Adjacency}}, \code{\link{LambdaGridGraphical}}, \code{\link{Resample}},
  \code{\link{GraphicalAlgo}}, \code{\link{Combine}},
  \code{\link{StabilityScore}}

Other stability selection functions: 
\code{\link{BiSelection}()},
\code{\link{VariableSelection}()}
}
\concept{stability selection functions}
