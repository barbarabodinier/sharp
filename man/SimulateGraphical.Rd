% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/simulations.R
\name{SimulateGraphical}
\alias{SimulateGraphical}
\title{Simulation of data with underlying graph structure}
\usage{
SimulateGraphical(
  n = 100,
  pk = 10,
  theta = NULL,
  implementation = SimulateAdjacency,
  topology = "random",
  nu_within = 0.1,
  nu_between = NULL,
  output_matrices = FALSE,
  v_within = c(-1, 1),
  v_between = c(-0.1, 0.1),
  continuous = FALSE,
  pd_strategy = "diagonally_dominant",
  u = NULL,
  niter_max_u_grid = 5,
  tolerance_u_grid = 10,
  u_delta = 5,
  ...
)
}
\arguments{
\item{n}{number of observations in the simulated data.}

\item{pk}{vector of the number of variables per group in the simulated data.
The number of nodes in the simulated graph is \code{sum(pk)}. With multiple
groups, the simulated (partial) correlation matrix has a block structure,
where blocks arise from the integration of the \code{length(pk)} groups.
This argument is only used if \code{sum(pk)} is equal to the number of
rows/columns in \code{theta} is not provided.}

\item{theta}{optional binary and symmetric adjacency matrix encoding the
conditional independence structure.}

\item{implementation}{function for simulation of the graph. By default,
functionalities implemented in \code{\link[huge]{huge.generator}} are used.
Alternatively, a user-defined function can be used. It must take \code{pk},
\code{topology} and \code{nu} as arguments and return a
\code{(sum(pk)*(sum(pk)))} binary and symmetric matrix for which diagonal
entries are all equal to zero. This function is only applied if
\code{theta} is not provided.}

\item{topology}{topology of the simulated graph. If using
\code{implementation=SimulateAdjacency}, possible values are listed for the
argument \code{graph} of \code{\link[huge]{huge.generator}}. These are:
"random", "hub", "cluster", "band" and "scale-free".}

\item{nu_within}{expected density of within-group blocks in the graph. If
\code{length(pk)=1}, this is the expected density of the graph. If
\code{implementation=SimulateAdjacency}, this argument is only used for
\code{topology="random"} or \code{topology="cluster"} (see argument
\code{prob} in \code{\link[huge]{huge.generator}}).}

\item{nu_between}{expected density of between-group blocks in the graph.
Similar to \code{nu_within}. By default, the same density is used for
within and between blocks (\code{nu_within}=\code{nu_between}). Only used
if \code{length(pk)>1}.}

\item{output_matrices}{logical indicating if the true precision and (partial)
correlation matrices should be included in the output.}

\item{v_within}{vector defining the (range of) nonzero entries in the
diagonal blocks of the precision matrix. If \code{continuous=FALSE},
\code{v_within} is the set of possible precision values. If
\code{continuous=FALSE}, \code{v_within} is the range of possible precision
values.}

\item{v_between}{vector defining the (range of) nonzero entries in the
off-diagonal blocks of the precision matrix. If \code{continuous=FALSE},
\code{v_between} is the set of possible precision values. If
\code{continuous=FALSE}, \code{v_between} is the range of possible
precision values. This argument is only used if \code{length(pk)>1}.}

\item{continuous}{logical indicating whether to sample precision values from
a uniform distribution between the minimum and maximum values in
\code{v_within} (diagonal blocks) or \code{v_between} (off-diagonal blocks)
(\code{continuous=TRUE}) or from proposed values in \code{v_within}
(diagonal blocks) or \code{v_between} (off-diagonal blocks)
(\code{continuous=FALSE}).}

\item{pd_strategy}{method to ensure that the generated precision matrix is
positive definite (and hence can be a covariance matrix). With
\code{pd_strategy="diagonally_dominant"}, the precision matrix is made
diagonally dominant by setting the diagonal entries to the sum of absolute
values on the corresponding row and a constant u. With
\code{pd_strategy="nonnegative_eigenvalues"}, diagonal entries are set to
the sum of the absolute value of the smallest eigenvalue and a constant u.}

\item{u}{optional vector of values for constant u used to ensure positive
definiteness of the simulated precision matrix. The value that maximises
the contrast of the simulated correlation matrix over the grid \code{u} is
used. If \code{u=NULL}, a grid of values is automatically generated and
iteratively shifted to ensure that the chosen value is not an extreme
value.}

\item{niter_max_u_grid}{maximum number of iterations where the grid of u
values is shifted. This parameter is only used with \code{u=NULL}.}

\item{tolerance_u_grid}{number of values between the chosen value for u and
the end of the grid (first or last value). This parameter is only used with
\code{u=NULL}.}

\item{u_delta}{difference in log10-scale between the smallest (or largest) u
values in the grid used in the current iteration and the one built for next
iteration. This parameter is only used with \code{u=NULL}.}

\item{...}{additional arguments passed to the graph simulation function
provided in \code{implementation}.}
}
\value{
A list with: \item{data}{simulated data with \code{n} observation and
  \code{sum(pk)} variables.} \item{theta}{adjacency matrix of the simulated
  graph} \item{omega}{true simulated precision matrix. Only returned if
  \code{output_matrices=TRUE}.} \item{phi}{true simulated partial correlation
  matrix. Only returned if \code{output_matrices=TRUE}.} \item{C}{true
  simulated correlation matrix. Only returned if
  \code{output_matrices=TRUE}.} \item{u}{chosen value of u. Only returned if
  \code{output_matrices=TRUE}.} \item{u_grid}{grid of u values. Only returned
  if \code{output_matrices=TRUE}.} \item{contrast_path}{contrast values
  obtained for the values of u listed in u_grid. Only returned if
  \code{output_matrices=TRUE}.}
}
\description{
Simulates (i) a graph, and (ii) multivariate Normal data for which the graph
structure is encoded in the nonzero entries of the true partial correlation
matrix. This procedure ensures that the conditional independence structure
between the variables is encoded in the simulated graph. The outputs of this
function can be used to evaluate the ability of a graphical model to identify
edges of a conditional independence graph.
}
\examples{
\dontrun{

# Simulation of random graph with 50 nodes
set.seed(1)
simul <- SimulateGraphical(n = 100, pk = 50, topology = "random", nu_within = 0.05)
dim(simul$data) # dimension of simulated dataset
sum(simul$theta) / 2 # number of edges
plot(Graph(simul$theta))

# Simulation of scale-free graph with 20 nodes
set.seed(1)
simul <- SimulateGraphical(n = 100, pk = 20, topology = "scale-free")
plot(Graph(simul$theta))

# Extracting true precision/correlation matrices
set.seed(1)
simul <- SimulateGraphical(
  n = 100, pk = 20,
  topology = "scale-free", output_matrices = TRUE
)
str(simul)

# Simulation of multi-block data
set.seed(1)
pk <- c(20, 30)
simul <- SimulateGraphical(n = 100, pk = pk, nu_within = 0.05)
mycor <- cor(simul$data)
Heatmap(mycor,
  colours = c("darkblue", "white", "firebrick3"),
  legend_range = c(-1, 1), legend_length = 50, legend = FALSE
)
for (i in 1:2) {
  axis(side = i, at = c(0.5, pk[1] - 0.5), labels = NA)
  axis(
    side = i, at = mean(c(0.5, pk[1] - 0.5)),
    labels = ifelse(i == 1, yes = "Group 1", no = "Group 2"),
    tick = FALSE, cex.axis = 1.5
  )
  axis(side = i, at = c(pk[1] + 0.5, sum(pk) - 0.5), labels = NA)
  axis(
    side = i, at = mean(c(pk[1] + 0.5, sum(pk) - 0.5)),
    labels = ifelse(i == 1, yes = "Group 2", no = "Group 1"),
    tick = FALSE, cex.axis = 1.5
  )
}

# User-defined function for graph simulation
CentralNode <- function(pk, topology = NULL, nu = NULL, hub = 1) {
  theta <- matrix(0, nrow = sum(pk), ncol = sum(pk))
  theta[hub, ] <- 1
  theta[, hub] <- 1
  diag(theta) <- 0
  return(theta)
}
simul <- SimulateGraphical(n = 100, pk = 10, implementation = CentralNode)
plot(Graph(simul$theta)) # star
simul <- SimulateGraphical(n = 100, pk = 10, implementation = CentralNode, hub = 2)
plot(Graph(simul$theta)) # variable 2 is the central node

# User-defined adjacency matrix
mytheta <- matrix(c(
  0, 1, 1, 0,
  1, 0, 0, 0,
  1, 0, 0, 1,
  0, 0, 1, 0
), ncol = 4, byrow = TRUE)
simul <- SimulateGraphical(n = 100, theta = mytheta)

# User-defined adjacency and block structure
simul <- SimulateGraphical(n = 100, theta = mytheta, pk = c(2, 2))
mycor <- cor(simul$data)
Heatmap(mycor,
  colours = c("darkblue", "white", "firebrick3"),
  legend_range = c(-1, 1), legend_length = 50, legend = FALSE
)
}
}
\seealso{
\code{\link{SimulatePrecision}}, \code{\link{MakePositiveDefinite}},
  \code{\link{Contrast}}, \code{\link{GraphicalModel}}

Other simulation functions: 
\code{\link{SimulateAdjacency}()},
\code{\link{SimulateBlockAdjacency}()},
\code{\link{SimulateClustering}()},
\code{\link{SimulateRegression}()}
}
\concept{simulation functions}
