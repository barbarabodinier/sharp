% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/roc.R
\name{Incremental}
\alias{Incremental}
\title{Incremental prediction performance in regression}
\usage{
Incremental(
  xdata,
  ydata,
  stability = NULL,
  family = NULL,
  n_predictors = NULL,
  K = 100,
  tau = 0.8,
  seed = 1,
  n_thr = NULL,
  ij_method = FALSE,
  time = 1000
)
}
\arguments{
\item{xdata}{matrix of predictors with observations as rows and variables as
columns.}

\item{ydata}{optional vector or matrix of outcome(s). If \code{family} is set
to \code{"binomial"} or \code{"multinomial"}, \code{ydata} can be a vector
with character/numeric values, or a factor.}

\item{stability}{output of \code{\link{VariableSelection}}. With
\code{stability=NULL} (the default), a model including all variables in
\code{xdata} as predictors is fitted. Argument \code{family} must be
provided in this case.}

\item{family}{type of regression model. Possible values include
\code{"gaussian"} (linear regression), \code{"binomial"} (logistic
regression), \code{"multinomial"} (multinomial regression), and
\code{"cox"} (survival analysis). This argument must be consistent with
input \code{stability}, if provided.}

\item{n_predictors}{number of predictors to consider.}

\item{K}{number of subsampling iterations.}

\item{tau}{proportion of observations used in the training set.}

\item{seed}{value of the seed to ensure reproducibility of the results.}

\item{n_thr}{number of thresholds to use to construct the ROC curve. For
faster computations on large data, values below \code{length(x)-1} can be
used. Only used for logistic regression.}

\item{ij_method}{logical indicating if the analysis should be done for only
one recalibration/test split with variance of the concordance index should
be computed using the infinitesimal jackknife method as implemented in
\code{\link[survival]{concordance}}. With \code{ij_method=TRUE}, the
concordance index and estimated confidence interval at level 0.05 are
reported. With \code{ij_method=FALSE} (the default), the concordance
indices computed for different recalibration/test splits are reported.}

\item{time}{numeric indicating the time for which the survival probabilities
are computed. Only used for Cox regression.}
}
\value{
For logistic regression, a list with: \item{FPR}{A list with, for
  each of the models (sequentially added predictors), the False Positive
  Rates for different thresholds (columns) and different data splits (rows).}
  \item{TPR}{A list with, for each of the models (sequentially added
  predictors), the True Positive Rates for different thresholds (columns) and
  different data splits (rows).} \item{AUC}{A list with, for each of the
  models (sequentially added predictors), a vector of Area Under the Curve
  (AUC) values obtained with different data splits.} \item{names}{Names of
  the predictors by order of inclusion.}

  For Cox models, a list with: \item{concordance}{If \code{ij_method=FALSE},
  a list with, for each of the models (sequentially added predictors), a
  vector of concordance indices obtained with different data splits. If
  \code{ij_method=TRUE}, a vector of concordance indices for each of the
  models (sequentially added predictors).} \item{lower}{A vector of the lower
  bound of the confidence interval at level 0.05 for concordance indices for
  each of the models (sequentially added predictors). Only returned if
  \code{ij_method=TRUE}.} \item{upper}{A vector of the upper bound of the
  confidence interval at level 0.05 for concordance indices for each of the
  models (sequentially added predictors). Only returned if
  \code{ij_method=TRUE}.} \item{names}{Names of the predictors by order of
  inclusion.}
}
\description{
Computes the prediction performance for logistic or Cox regression models
where predictors are sequentially added by order of decreasing selection
proportion. This function can be used to evaluate the marginal contribution
of each of the selected predictors over and above more stable predictors.
Performances are evaluated as in \code{\link{ExplanatoryPerformance}}.
}
\examples{
\dontrun{
## Logistic regression

# Data simulation
set.seed(1)
simul <- SimulateRegression(n = 1000, pk = 50, family = "binomial")

# Balanced split: 50\% variable selection set and 50\% for evaluation of performances
ids_train <- Resample(data = simul$ydata, tau = 0.5)
xtrain <- simul$xdata[ids_train, ]
ytrain <- simul$ydata[ids_train, ]
xtest <- simul$xdata[-ids_train, ]
ytest <- simul$ydata[-ids_train, ]

# Stability selection
stab <- VariableSelection(xdata = xtrain, ydata = ytrain, family = "binomial")

# Evaluating marginal contribution of the predictors
perf <- Incremental(xdata = xtest, ydata = ytest, stability = stab, K = 10)
PlotIncremental(perf)


## Cox regression

# Data simulation
set.seed(1)
simul <- SimulateRegression(n = 1000, pk = 50, family = "binomial")
ydata <- cbind(
  time = runif(nrow(simul$ydata), min = 100, max = 2000),
  case = simul$ydata[, 1]
) # including dummy time to event

# Balanced split: 50\% variable selection set and 50\% for evaluation of performances
ids_train <- Resample(data = simul$ydata, tau = 0.5)
xtrain <- simul$xdata[ids_train, ]
ytrain <- ydata[ids_train, ]
xtest <- simul$xdata[-ids_train, ]
ytest <- ydata[-ids_train, ]

# Stability selection
stab <- VariableSelection(xdata = xtrain, ydata = ytrain, family = "cox")

# Marginal contribution
perf <- Incremental(xdata = xtest, ydata = ytest, stability = stab, K = 10)
PlotIncremental(perf)

# Faster computations on a single data split
perf <- Incremental(xdata = xtest, ydata = ytest, stability = stab, ij_method = TRUE)
PlotIncremental(perf)
}

}
\seealso{
\code{\link{VariableSelection}}, \code{\link{Recalibrate}}

Other prediction performance functions: 
\code{\link{ExplanatoryPerformance}()},
\code{\link{PlotIncremental}()},
\code{\link{PlotROC}()},
\code{\link{ROC}()}
}
\concept{prediction performance functions}
