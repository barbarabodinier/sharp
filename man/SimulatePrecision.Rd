% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/simulations.R
\name{SimulatePrecision}
\alias{SimulatePrecision}
\title{Simulation of a precision matrix}
\usage{
SimulatePrecision(
  pk = NULL,
  theta,
  v_within = c(-1, 1),
  v_between = c(-0.1, 0.1),
  continuous = TRUE,
  pd_strategy = "diagonally_dominant",
  u = NULL,
  niter_max_u_grid = 5,
  tolerance_u_grid = 10,
  u_delta = 5
)
}
\arguments{
\item{pk}{vector of the number of variables per group in the simulated data.
The number of nodes in the simulated graph is \code{sum(pk)}. With multiple
groups, the simulated (partial) correlation matrix has a block structure,
where blocks arise from the integration of the \code{length(pk)} groups.
This argument is only used if \code{sum(pk)} is equal to the number of
rows/columns in \code{theta} is not provided.}

\item{theta}{binary and symmetric adjacency matrix encoding the conditional
independence structure.}

\item{v_within}{vector defining the (range of) nonzero entries in the
diagonal blocks of the precision matrix. These values must be between -1
and 1 if \code{pd_strategy="min_eigenvalue"}. If \code{continuous=FALSE},
\code{v_within} is the set of possible precision values. If
\code{continuous=TRUE}, \code{v_within} is the range of possible precision
values.}

\item{v_between}{vector defining the (range of) nonzero entries in the
off-diagonal blocks of the precision matrix. This argument is the same as
\code{v_within} but for off-diagonal blocks. It is only used if
\code{length(pk)>1}.}

\item{continuous}{logical indicating whether to sample precision values from
a uniform distribution between the minimum and maximum values in
\code{v_within} (diagonal blocks) or \code{v_between} (off-diagonal blocks)
(\code{continuous=TRUE}) or from proposed values in \code{v_within}
(diagonal blocks) or \code{v_between} (off-diagonal blocks)
(\code{continuous=FALSE}).}

\item{pd_strategy}{method to ensure that the generated precision matrix is
positive definite (and hence can be a covariance matrix). With
\code{pd_strategy="diagonally_dominant"}, the precision matrix is made
diagonally dominant by setting the diagonal entries to the sum of absolute
values on the corresponding row and a constant u. With
\code{pd_strategy="min_eigenvalue"}, diagonal entries are set to the sum of
the absolute value of the smallest eigenvalue and a constant u.}

\item{u}{optional vector of values for constant u > 0 used to ensure positive
definiteness of the simulated precision matrix. If
\code{pd_strategy="diagonally_dominant"}, the value that maximises the
contrast of the simulated correlation matrix over the grid \code{u} is
used. If \code{u=NULL}, a grid of values is automatically generated and
iteratively shifted to ensure that the chosen value is not an extreme
value. If \code{pd_strategy="min_eigenvalue"}, a single value for \code{u}
is used (default is \code{u=1e-5}).}

\item{niter_max_u_grid}{maximum number of iterations where the grid of u
values is shifted. This parameter is only used with
\code{pd_strategy="diagonally_dominant"} and \code{u=NULL}.}

\item{tolerance_u_grid}{number of values between the chosen value for u and
the end of the grid (first or last value). This parameter is only used with
\code{pd_strategy="diagonally_dominant"} and \code{u=NULL}.}

\item{u_delta}{difference in log10-scale between the smallest (or largest) u
values in the grid used in the current iteration and the one built for next
iteration. This parameter is only used with
\code{pd_strategy="diagonally_dominant"} and \code{u=NULL}.}
}
\value{
A list with: \item{omega}{true simulated precision matrix.}
  \item{u}{value of the constant u used for the simulation of \code{omega}.}
  \item{u_grid}{grid of u values (only returned if
  \code{pd_strategy="diagonally_dominant"}).} \item{contrast_path}{contrast
  values obtained for the values of u listed in \code{u_grid} (only returned
  if \code{pd_strategy="diagonally_dominant"}).}
}
\description{
Simulates a sparse precision matrix from an adjacency matrix \code{theta}
encoding a conditional independence graph. Zero entries in the precision
matrix indicate pairwise conditional independence.
}
\examples{
\dontrun{

# Simulation of an adjacency matrix
theta <- SimulateAdjacency(pk = c(5, 5))
print(theta)

# Simulation of a precision matrix
simul <- SimulatePrecision(theta = theta)
print(simul$omega)

# Simulation of a precision matrix
simul <- SimulatePrecision(
  theta = theta,
  pd_strategy = "min_eigenvalue"
)
print(simul$omega)
}
}
