% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/simulations.R
\name{SimulateClustering}
\alias{SimulateClustering}
\title{Simulation of data with underlying clusters}
\usage{
SimulateClustering(
  n = c(10, 10),
  pk = 10,
  adjacency = NULL,
  theta_xc = NULL,
  nu_xc = 0.1,
  ev = NULL,
  implementation = HugeAdjacency,
  topology = "random",
  nu_within = 0,
  nu_between = NULL,
  v_within = c(0.5, 1),
  v_between = c(0, 0.1),
  v_sign = c(-1, 1),
  continuous = TRUE,
  pd_strategy = "min_eigenvalue",
  u = NULL,
  niter_max_u_grid = 5,
  tolerance_u_grid = 10,
  u_delta = 5,
  output_matrices = FALSE
)
}
\arguments{
\item{n}{vector of the number of observations per cluster in the simulated
data. The number of observations in the simulated data is \code{sum(n)}.}

\item{pk}{vector of the number of variables in the simulated data.}

\item{adjacency}{optional binary and symmetric adjacency matrix encoding the
conditional independence structure between variables.}

\item{theta_xc}{optional binary vector encoding which variables (columns)
contribute to the clustering structure between observations (rows).}

\item{nu_xc}{expected proportion of variables contributing to the clustering
over the total number of variables. This argument is only used if
\code{theta_xc} is not provided.}

\item{ev}{vector of marginal expected proportion of explained for each
variable contributing to the clustering. This parameter is only used for
variables with a nonzero entry in \code{theta_xc}.}

\item{implementation}{function for simulation of the graph. By default,
algorithms implemented in \code{\link[huge]{huge.generator}} are used.
Alternatively, a user-defined function can be used. It must take \code{pk},
\code{topology} and \code{nu} as arguments and return a
\code{(sum(pk)*(sum(pk)))} binary and symmetric matrix for which diagonal
entries are all equal to zero. This function is only applied if
\code{theta} is not provided.}

\item{topology}{topology of the simulated graph. If using
\code{implementation=HugeAdjacency}, possible values are listed for the
argument \code{graph} of \code{\link[huge]{huge.generator}}. These are:
"random", "hub", "cluster", "band" and "scale-free".}

\item{nu_within}{expected density (number of edges over the number of node
pairs) of within-group blocks in the graph. If \code{length(pk)=1}, this is
the expected density of the graph. If \code{implementation=HugeAdjacency},
this argument is only used for \code{topology="random"} or
\code{topology="cluster"} (see argument \code{prob} in
\code{\link[huge]{huge.generator}}).}

\item{nu_between}{expected density (number of edges over the number of node
pairs) of between-group blocks in the graph. Similar to \code{nu_within}.
By default, the same density is used for within and between blocks
(\code{nu_within}=\code{nu_between}). Only used if \code{length(pk)>1}.}

\item{v_within}{vector defining the (range of) nonzero entries in the
diagonal blocks of the precision matrix. These values must be between -1
and 1 if \code{pd_strategy="min_eigenvalue"}. If \code{continuous=FALSE},
\code{v_within} is the set of possible precision values. If
\code{continuous=TRUE}, \code{v_within} is the range of possible precision
values.}

\item{v_between}{vector defining the (range of) nonzero entries in the
off-diagonal blocks of the precision matrix. This argument is the same as
\code{v_within} but for off-diagonal blocks. It is only used if
\code{length(pk)>1}.}

\item{v_sign}{vector of possible signs for precision matrix entries. Possible
inputs are: \code{-1} for positive partial correlations, \code{1} for
negative partial correlations, or \code{c(-1, 1)} for both positive and
negative partial correlations.}

\item{continuous}{logical indicating whether to sample precision values from
a uniform distribution between the minimum and maximum values in
\code{v_within} (diagonal blocks) or \code{v_between} (off-diagonal blocks)
(\code{continuous=TRUE}) or from proposed values in \code{v_within}
(diagonal blocks) or \code{v_between} (off-diagonal blocks)
(\code{continuous=FALSE}).}

\item{pd_strategy}{method to ensure that the generated precision matrix is
positive definite (and hence can be a covariance matrix). With
\code{pd_strategy="diagonally_dominant"}, the precision matrix is made
diagonally dominant by setting the diagonal entries to the sum of absolute
values on the corresponding row and a constant u. With
\code{pd_strategy="min_eigenvalue"}, diagonal entries are set to the sum of
the absolute value of the smallest eigenvalue and a constant u.}

\item{u}{optional vector of values for constant u > 0 used to ensure positive
definiteness of the simulated precision matrix. If
\code{pd_strategy="diagonally_dominant"}, the value that maximises the
contrast of the simulated correlation matrix over the grid \code{u} is
used. If \code{u=NULL}, a grid of values is automatically generated and
iteratively shifted to ensure that the chosen value is not an extreme
value. If \code{pd_strategy="min_eigenvalue"}, a single value for \code{u}
is used (default is \code{u=1e-5}).}

\item{niter_max_u_grid}{maximum number of iterations where the grid of u
values is shifted. This parameter is only used with
\code{pd_strategy="diagonally_dominant"} and \code{u=NULL}.}

\item{tolerance_u_grid}{number of values between the chosen value for u and
the end of the grid (first or last value). This parameter is only used with
\code{pd_strategy="diagonally_dominant"} and \code{u=NULL}.}

\item{u_delta}{difference in log10-scale between the smallest (or largest) u
values in the grid used in the current iteration and the one built for next
iteration. This parameter is only used with
\code{pd_strategy="diagonally_dominant"} and \code{u=NULL}.}

\item{output_matrices}{logical indicating if the true precision and (partial)
correlation matrices should be included in the output.}
}
\value{
A list with: \item{data}{simulated data with \code{sum(n)}
  observation and \code{sum(pk)} variables} \item{theta}{simulated (true)
  cluster membership.} \item{theta}{adjacency matrix of the graph encoding
  the conditional independence structure between variables.}
  \item{theta_xc}{binary vector encoding variables contributing to the
  clustering structure.} \item{ev}{vector of marginal expected proportions of
  explained variance for each variable.}
}
\description{
Simulates mixture multivariate Normal data with clusters of observations
(rows) sharing similar profiles along (a subset of) variables (columns). The
conditional independence structure between the variables can be simulated or
provided in argument \code{adjacency}. The same covariance is used across all
clusters. Independent variables are simulated by default
(\code{nu_within=0}).
}
\examples{
\dontrun{
## Example with 3 clusters

# Data simulation
set.seed(1)
simul <- SimulateClustering(
  n = c(10, 30, 15)
)

# Visualisation of Euclidian distances
par(mar = c(5, 5, 5, 5))
Heatmap(
  mat = as.matrix(dist(simul$data)),
  colours = c("navy", "white", "red")
)


## Example with 2 variables contributing to clustering

# Data simulation
set.seed(1)
simul <- SimulateClustering(
  n = c(200, 100, 150), pk = 10,
  theta_xc = c(1, 1, rep(0, 8))
)

# Visualisation of the data
par(mar = c(5, 5, 5, 5))
Heatmap(
  mat = simul$data,
  colours = c("navy", "white", "red")
)
simul$ev # marginal proportions of explained variance

# Visualisation along contributing variables
plot(simul$data[, 1:2], col = simul$theta)


## Example with more distinct clusters

# Data simulation
set.seed(1)
simul <- SimulateClustering(
  n = c(200, 100, 150), pk = 10,
  theta_xc = c(1, 1, rep(0, 8)),
  ev = c(0.9, 0.8, rep(0, 8))
)

# Visualisation along contributing variables
plot(simul$data[, 1:2], col = simul$theta)


## Example with correlated contributors

# Data simulation
pk <- 10
adjacency <- matrix(0, pk, pk)
adjacency[1, 2] <- adjacency[2, 1] <- 1
set.seed(1)
simul <- SimulateClustering(
  n = c(200, 100, 150), pk = pk,
  theta_xc = c(1, 1, rep(0, 8)),
  ev = c(0.9, 0.8, rep(0, 8)),
  adjacency = adjacency,
  pd_strategy = "min_eigenvalue",
  v_within = 0.6, v_sign = -1
)

# Visualisation along contributing variables
plot(simul$data[, 1:2], col = simul$theta)

# Checking marginal proportions of explained variance
mymodel <- lm(simul$data[, 1] ~ as.factor(simul$theta))
summary(mymodel)$r.squared
mymodel <- lm(simul$data[, 2] ~ as.factor(simul$theta))
summary(mymodel)$r.squared
}
}
\seealso{
\code{\link{MakePositiveDefinite}}, \code{\link{GraphicalModel}}

Other simulation functions: 
\code{\link{HugeAdjacency}()},
\code{\link{SimulateAdjacency}()},
\code{\link{SimulateComponents}()},
\code{\link{SimulateGraphical}()},
\code{\link{SimulateRegression}()}
}
\concept{simulation functions}
