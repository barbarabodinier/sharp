% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/simulations.R
\name{SimulateClustering}
\alias{SimulateClustering}
\title{Simulation of data with underlying clusters}
\usage{
SimulateClustering(
  n = c(10, 10),
  pk = 20,
  adjacency = NULL,
  nu_within = 1,
  nu_between = 0,
  v_within = c(-1, -0.9),
  v_between = -0.1,
  continuous = TRUE,
  pd_strategy = "min_eigenvalue",
  u = NULL,
  niter_max_u_grid = 5,
  tolerance_u_grid = 10,
  u_delta = 5,
  output_matrices = FALSE
)
}
\arguments{
\item{n}{vector of the number of observations per cluster in the simulated
data. The number of observations in the simulated data is \code{sum(n)}.}

\item{pk}{vector of the number of variables in the simulated data.}

\item{adjacency}{optional binary and symmetric adjacency matrix encoding the
conditional graph structure between observations. The clusters encoded in
this argument must be in line with those indicated in \code{n}. To generate
a block structure, the within-cluster observations must be more likely to
be correlated than between clusters. For between-cluster relationships to
be apparent, \code{v_between} must be nonzero.}

\item{nu_within}{expected density of within-group blocks in the graph. If
\code{length(pk)=1}, this is the expected density of the graph. If
\code{implementation=SimulateAdjacency}, this argument is only used for
\code{topology="random"} or \code{topology="cluster"} (see argument
\code{prob} in \code{\link[huge]{huge.generator}}).}

\item{nu_between}{expected density of between-group blocks in the graph.
Similar to \code{nu_within}. By default, the same density is used for
within and between blocks (\code{nu_within}=\code{nu_between}). Only used
if \code{length(pk)>1}.}

\item{v_within}{vector defining the (range of) nonzero entries in the
diagonal blocks of the precision matrix. These values must be between -1
and 1 if \code{pd_strategy="min_eigenvalue"}. If \code{continuous=FALSE},
\code{v_within} is the set of possible precision values. If
\code{continuous=TRUE}, \code{v_within} is the range of possible precision
values.}

\item{v_between}{vector defining the (range of) nonzero entries in the
off-diagonal blocks of the precision matrix. This argument is the same as
\code{v_within} but for off-diagonal blocks. It is only used if
\code{length(pk)>1}.}

\item{continuous}{logical indicating whether to sample precision values from
a uniform distribution between the minimum and maximum values in
\code{v_within} (diagonal blocks) or \code{v_between} (off-diagonal blocks)
(\code{continuous=TRUE}) or from proposed values in \code{v_within}
(diagonal blocks) or \code{v_between} (off-diagonal blocks)
(\code{continuous=FALSE}).}

\item{pd_strategy}{method to ensure that the generated precision matrix is
positive definite (and hence can be a covariance matrix). With
\code{pd_strategy="diagonally_dominant"}, the precision matrix is made
diagonally dominant by setting the diagonal entries to the sum of absolute
values on the corresponding row and a constant u. With
\code{pd_strategy="min_eigenvalue"}, diagonal entries are set to the sum of
the absolute value of the smallest eigenvalue and a constant u.}

\item{u}{optional vector of values for constant u used to ensure positive
definiteness of the simulated precision matrix. The value that maximises
the contrast of the simulated correlation matrix over the grid \code{u} is
used. If \code{u=NULL}, a grid of values is automatically generated and
iteratively shifted to ensure that the chosen value is not an extreme
value.}

\item{niter_max_u_grid}{maximum number of iterations where the grid of u
values is shifted. This parameter is only used with \code{u=NULL}.}

\item{tolerance_u_grid}{number of values between the chosen value for u and
the end of the grid (first or last value). This parameter is only used with
\code{u=NULL}.}

\item{u_delta}{difference in log10-scale between the smallest (or largest) u
values in the grid used in the current iteration and the one built for next
iteration. This parameter is only used with \code{u=NULL}.}

\item{output_matrices}{logical indicating if the true precision and (partial)
correlation matrices should be included in the output.}
}
\value{
A list with: \item{data}{simulated data with \code{n} observation and
  \code{sum(pk)} variables} \item{theta}{adjacency matrix of the simulated
  graph} \item{omega}{true simulated precision matrix. Only returned if
  \code{output_matrices=TRUE}.} \item{phi}{true simulated partial correlation
  matrix. Only returned if \code{output_matrices=TRUE}.} \item{C}{true
  simulated correlation matrix. Only returned if
  \code{output_matrices=TRUE}.} \item{u}{chosen value of u. Only returned if
  \code{output_matrices=TRUE}.} \item{u_grid}{grid of u values. Only returned
  if \code{output_matrices=TRUE}.} \item{contrast_path}{contrast values
  obtained for the values of u listed in u_grid. Only returned if
  \code{output_matrices=TRUE}.}
}
\description{
Simulates multivariate Normal data with clusters of participants sharing
similar variable profiles. This simulator is based on a graph structure
encoding conditional correlations between the observations.
}
\details{
By default, with \code{nu=1}, a graph with \code{length(n)} fully
  connected components is used to infer the covariance matrix (between
  observations). The data is simulated from the multivariate Normal
  distribution with the generated covariance. This is based on similar
  computations to \code{\link{SimulateGraphical}} but applied on the
  transpose of the data matrix (i.e. encoding relationships between
  observations instead of variables). Using a smaller value for \code{nu} or
  a larger range for \code{v_within} will generate more heterogeneous blocks
  of correlated observations. Note that as \code{v_within} is controlling
  entries in the precision matrix, all values must be negative to generate
  positive correlations.
}
\examples{
\dontrun{

# Simulation of 15 observations belonging to 3 groups
set.seed(1)
simul <- SimulateClustering(n = c(10, 10, 10), pk = 50)
par(mar = c(5, 5, 5, 5))
Heatmap(
  mat = cor(t(simul$data)),
  colours = c("navy", "white", "red"),
  legend_range = c(-1, 1)
)

# Simulation with weaker within-cluster correlations
set.seed(1)
simul <- SimulateClustering(
  n = c(10, 10, 10), pk = 50,
  v_within = c(-1, -0.8), continuous = TRUE
)
par(mar = c(5, 5, 5, 5))
Heatmap(
  mat = cor(t(simul$data)),
  colours = c("navy", "white", "red"),
  legend_range = c(-1, 1)
)

# Simulation with different cluster sizes
set.seed(1)
simul <- SimulateClustering(
  n = c(10, 5, 5), pk = 50,
  v_within = c(-1, -0.8), continuous = TRUE
)
par(mar = c(5, 5, 5, 5))
Heatmap(
  mat = cor(t(simul$data)),
  colours = c("navy", "white", "red"),
  legend_range = c(-1, 1)
)

# Introducing between-cluster correlations
set.seed(1)
simul <- SimulateClustering(
  n = c(10, 10, 10), pk = 50,
  nu_within = 1, nu_between = 0.05,
  v_within = -1
)
par(mar = c(5, 5, 5, 5))
Heatmap(
  mat = cor(t(simul$data)),
  colours = c("navy", "white", "red"),
  legend_range = c(-1, 1)
)

# User-defined structure: between-cluster pair obs1-obs8
adjacency <- CoMembership(c(rep(1, 5), rep(2, 5), seq(3, 7)))
adjacency <- matrix(0, 15, 15)
adjacency[1, 1:5] <- adjacency[1:5, 1] <- 1
set.seed(1)
simul <- SimulateClustering(
  n = c(5, 5, 5), pk = 50, adjacency = adjacency, v_between = -1
)
par(mar = c(5, 5, 5, 5))
Heatmap(
  mat = cor(t(simul$data)),
  colours = c("navy", "white", "red"),
  legend_range = c(-1, 1)
)
}
}
\seealso{
\code{\link{MakePositiveDefinite}}, \code{\link{Contrast}},
  \code{\link{GraphicalModel}}

Other simulation functions: 
\code{\link{SimulateAdjacency}()},
\code{\link{SimulateBlockAdjacency}()},
\code{\link{SimulateGraphical}()},
\code{\link{SimulateRegression}()}

Other simulation functions: 
\code{\link{SimulateAdjacency}()},
\code{\link{SimulateBlockAdjacency}()},
\code{\link{SimulateGraphical}()},
\code{\link{SimulateRegression}()}
}
\concept{simulation functions}
