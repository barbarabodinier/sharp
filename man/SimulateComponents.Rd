% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/simulations.R
\name{SimulateComponents}
\alias{SimulateComponents}
\title{Simulation of sparse orthogonal components}
\usage{
SimulateComponents(
  n = 100,
  pk = c(10, 10),
  adjacency = NULL,
  nu_within = 1,
  v_within = c(0.5, 1),
  v_sign = c(-1, 1),
  continuous = TRUE,
  pd_strategy = "min_eigenvalue",
  u = NULL,
  niter_max_u_grid = 5,
  tolerance_u_grid = 10,
  u_delta = 5,
  output_matrices = FALSE
)
}
\arguments{
\item{n}{number of observations in the simulated data.}

\item{pk}{vector of the number of variables per group in the simulated data.
The number of nodes in the simulated graph is \code{sum(pk)}. With multiple
groups, the simulated (partial) correlation matrix has a block structure,
where blocks arise from the integration of the \code{length(pk)} groups.
This argument is only used if \code{sum(pk)} is equal to the number of
rows/columns in \code{theta} is not provided.}

\item{adjacency}{optional binary and symmetric adjacency matrix encoding the
conditional graph structure between observations. The clusters encoded in
this argument must be in line with those indicated in \code{pk}. Edges in
off-diagonal blocks are not allowed to ensure that the simulated orthogonal
components are sparse. Corresponding entries in the precision matrix will
be set to zero.}

\item{nu_within}{expected density (number of edges over the number of node
pairs) of within-group blocks in the graph. If \code{length(pk)=1}, this is
the expected density of the graph. If \code{implementation=HugeAdjacency},
this argument is only used for \code{topology="random"} or
\code{topology="cluster"} (see argument \code{prob} in
\code{\link[huge]{huge.generator}}).}

\item{v_within}{vector defining the (range of) nonzero entries in the
diagonal blocks of the precision matrix. These values must be between -1
and 1 if \code{pd_strategy="min_eigenvalue"}. If \code{continuous=FALSE},
\code{v_within} is the set of possible precision values. If
\code{continuous=TRUE}, \code{v_within} is the range of possible precision
values.}

\item{v_sign}{vector of possible signs for precision matrix entries. Possible
inputs are: \code{-1} for positive partial correlations, \code{1} for
negative partial correlations, or \code{c(-1, 1)} for both positive and
negative partial correlations.}

\item{continuous}{logical indicating whether to sample precision values from
a uniform distribution between the minimum and maximum values in
\code{v_within} (diagonal blocks) or \code{v_between} (off-diagonal blocks)
(\code{continuous=TRUE}) or from proposed values in \code{v_within}
(diagonal blocks) or \code{v_between} (off-diagonal blocks)
(\code{continuous=FALSE}).}

\item{pd_strategy}{method to ensure that the generated precision matrix is
positive definite (and hence can be a covariance matrix). With
\code{pd_strategy="diagonally_dominant"}, the precision matrix is made
diagonally dominant by setting the diagonal entries to the sum of absolute
values on the corresponding row and a constant u. With
\code{pd_strategy="min_eigenvalue"}, diagonal entries are set to the sum of
the absolute value of the smallest eigenvalue and a constant u.}

\item{u}{optional vector of values for constant u > 0 used to ensure positive
definiteness of the simulated precision matrix. If
\code{pd_strategy="diagonally_dominant"}, the value that maximises the
contrast of the simulated correlation matrix over the grid \code{u} is
used. If \code{u=NULL}, a grid of values is automatically generated and
iteratively shifted to ensure that the chosen value is not an extreme
value. If \code{pd_strategy="min_eigenvalue"}, a single value for \code{u}
is used (default is \code{u=1e-5}).}

\item{niter_max_u_grid}{maximum number of iterations where the grid of u
values is shifted. This parameter is only used with
\code{pd_strategy="diagonally_dominant"} and \code{u=NULL}.}

\item{tolerance_u_grid}{number of values between the chosen value for u and
the end of the grid (first or last value). This parameter is only used with
\code{pd_strategy="diagonally_dominant"} and \code{u=NULL}.}

\item{u_delta}{difference in log10-scale between the smallest (or largest) u
values in the grid used in the current iteration and the one built for next
iteration. This parameter is only used with
\code{pd_strategy="diagonally_dominant"} and \code{u=NULL}.}

\item{output_matrices}{logical indicating if the true precision and (partial)
correlation matrices should be included in the output.}
}
\value{
A list with: \item{data}{simulated data with \code{n} observation and
  \code{sum(pk)} variables.} \item{loadings}{loadings coefficients of the
  orthogonal latent variables (principal components).} \item{theta}{support
  of the loadings coefficients.} \item{ev}{proportion of explained variance
  by each of the orthogonal latent variables.} \item{adjacency}{adjacency
  matrix of the simulated graph.} \item{omega}{simulated (true) precision
  matrix. Only returned if \code{output_matrices=TRUE}.} \item{phi}{simulated
  (true) partial correlation matrix. Only returned if
  \code{output_matrices=TRUE}.} \item{C}{ simulated (true) correlation
  matrix. Only returned if \code{output_matrices=TRUE}.}
}
\description{
Simulates variables following a multivariate Normal distribution that could
be obtained from a sparse linear combination of orthogonal latent variables.
This generates blocks of mutually independent variables, where all variables
from a block can be obtained from a linear combination of the same latent
variables. The latent variables would correspond to Principal Components from
a sparse Principal Component Analysis. The loadings coefficients, their
support, and the proportions of explained variance by each of the latent
variables are returned. This function can be used to evaluate the performance
of sparse Principal Component Analysis algorithms.
}
\details{
The data is simulated from a centered multivariate Normal
  distribution with a block-diagonal covariance matrix. Independence between
  variables from the different blocks ensures that sparse orthogonal
  components can be generated. The block-diagonal (partial) correlation
  matrix is obtained using a graph structure encoding the conditional
  independence between variables. The orthogonal latent variables are
  obtained from eigendecomposition of the true correlation matrix. The sparse
  eigenvectors contain the weights of the linear combination of variables to
  construct the latent variable (loadings coefficients). The proportion of
  explained variance by each of the latent variable is computed from
  eigenvalues. As latent variables are defined from the true correlation
  matrix, the number of sparse orthogonal components is not limited by the
  number of observations and is equal to \code{sum(pk)}.
}
\examples{
\dontrun{
# Simulation of 3 components with high e.v.
set.seed(1)
simul <- SimulateComponents(pk = c(5, 3, 4))
par(mar = c(5, 5, 5, 5))
Heatmap(
  mat = cor(simul$data),
  colours = c("navy", "white", "red"),
  legend_range = c(-1, 1)
)
plot(cumsum(simul$ev), ylim = c(0, 1), las = 1)
print(simul$ev)

# Simulation of multiple components with moderate e.v.
simul <- SimulateComponents(
  pk = sample(3:10, size = 5, replace = TRUE),
  nu_within = 0.3, v_within = c(0.8, 0.5), v_sign=-1
)
par(mar = c(5, 5, 5, 5))
Heatmap(
  mat = cor(simul$data),
  colours = c("navy", "white", "red"),
  legend_range = c(-1, 1)
)
plot(cumsum(simul$ev), ylim = c(0, 1), las = 1)
}
}
\seealso{
\code{\link{MakePositiveDefinite}}, \code{\link{GraphicalModel}}

Other simulation functions: 
\code{\link{HugeAdjacency}()},
\code{\link{SimulateAdjacency}()},
\code{\link{SimulateClustering}()},
\code{\link{SimulateGraphical}()},
\code{\link{SimulateRegression}()}
}
\concept{simulation functions}
